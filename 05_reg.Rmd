# Regressionstabellen  {#reg} 

```{r setup5, echo = F, message=F, warning = F}
.libPaths("D:/R-library4")
knitr::opts_chunk$set(collapse = TRUE)
knitr::opts_chunk$set(dpi=800)
# knitr::opts_chunk$set(collectcode = T)
library(Statamarkdown)
library(tidyverse)
library(kableExtra)
# stataexe <- "C:/Program Files (x86)/Stata13/StataSE-64.exe"
stataexe <- "C:/Program Files/Stata16/StataSE-64.exe"
knitr::opts_chunk$set(engine.path=list(stata=stataexe))
# baua <- readstata13::read.dta13("D:/Datenspeicher/BIBB_BAuA/BIBBBAuA_2018_suf1.0.dta",convert.factors = F)
```



## `regression` 

Regressionstabellen sind wohl *der* Klassiker des Tabellenexports.

Das grundsätzliche Vorgehen für das Erstellen von Regressionstabellen mit `esttab` ist etwas anders als bei den Deskriptionstabellen:

```{stata reg1, eval = F}
reg F518_SUF c.zpalter // einfaches Regressionsmodell
estimates store reg1 	 // Ergebnisse speichern
esttab reg1 // (ausgeblendet)
```

Mit `ereturn list` bekommen wir alle abrufbaren Informationen angezeigt:

```{stata reg2, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
}
reg F518_SUF c.zpalter // einfaches Regressionsmodell
estimates store reg1 	 // Ergebnisse speichern
ereturn list			     // abrufbare Informationen
```

Alle unter `e()` abgespeicherten Informationen können wir direkt in  unsere `esttab` einfügen.
Los geht's:

## Eine Tabelle, ein Modell

```{stata reg3, eval = F}
esttab reg1 // Tabelle mit Standard-Einstellungen
```

```{stata reg4, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1 // Tabelle mit Standard-Einstellungen
```

Das ist noch sehr *basic*. 
U.a. sind häufig statt der t-Werte die Standardfehler in Klammern genannt.
Grundsätzlich können wir folgende Kennzahlen anfordern:
+ `b` Regressionskoeffizienten
+ `se` Standardfehler 
+ `t`  t-Werte
+ `p`  p-Werte
+ `ci` 95%-Konfidenzintervalle
+ `beta` standardisierte Koeffizienten

```{stata reg5, eval = F}
esttab reg1, b se(%9.3f) label // Formatierung, SE statt t + Variablen Labels
```


```{stata reg5b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, b se(%9.3f) label // Formatierung, SE statt t + Variablen Labels
```

Außerdem wollen wir in der Regel nicht nur die Fallzahl, sondern auch weitere Informationen zum Modell angeben.
Dabei können wir auf die Liste, die wir vorhin bei `ereturn list` gesehen haben, zurückgreifen.
```{stata reg6, eval = F}
esttab reg1, b se(%9.3f) stats(N  r2 ll F) // Modellkennzahlen angeben (volle Liste oben bei ereturn list)
```


```{stata reg6b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, b se(%9.3f) stats(N  r2 ll F) // Modellkennzahlen angeben (volle Liste oben bei ereturn list)
```

Diese Informationen können wir natürlich auch labeln und formatieren wie wir es schon kennengelernt haben.
Auch `coeflabel` funktioniert hier so wie bei `tabstat` zuvor:
```{stata reg7, eval = F}
esttab reg1, b se(%9.3f) /// 
	stats(r2 r2_a N, fmt(%9.4f %9.4f %9.0fc) labels("R²" "adj. R²" "Observations")) /// N und R² labeln
	coeflabel(zpalter "Alter" _cons "Konstante")  // Koeffizienten links labeln
```


```{stata reg7b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, b se(%9.3f) /// 
	stats(r2 r2_a N, fmt(%9.4f %9.4f %9.0fc) labels("R²" "adj. R²" "Observations")) /// N und R² labeln
	coeflabel(zpalter "Alter" _cons "Konstante")  // Koeffizienten links labeln
```

Außerdem können wir mit `mtitles` die Beschrifung anpassen und mit `nonumbers` die Zahl oben ausblenden.
Mit `title` können wir einen Tabellentitel und mit `note` eine Notiz unten hinzufügen. 
Wenn wir mehrere Zeilen möchten, dann geben wir einfach `"Text in 1. Zeile" "Text in 2. Zeile"` an:
```{stata reg8, eval = F}
esttab reg1, b se(%9.3f) /// 
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	coeflabel(zpalter "Alter" _cons "Konstante") ///
	mtitles("1. Modell") /// 
	nonumbers ///
	title(Tabellentitel) 	/// Titel für die Tabelle
	addnotes("erste Anmerkung" "zweite Anmerkung darunter") // Notizen ganz unten
```


```{stata reg8b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, b se(%9.3f) /// 
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	coeflabel(zpalter "Alter" _cons "Konstante") ///
	mtitles("1. Modell") /// 
	nonumbers ///
	title(Tabellentitel) 	/// Titel für die Tabelle
	addnotes("erste Anmerkung" "zweite Anmerkung darunter") // Notizen ganz unten
```


Auch Signifikanzsterne anpassen, mit `star()`

```{stata reg9, eval = F}
esttab reg1, b se(%9.3f) /// 
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	coeflabel(zpalter "Alter" _cons "Konstante") ///
	star(+ 0.10 * 0.05 ** 0.01 *** 0.001 **** 0.0001)
```


```{stata reg9b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, b se(%9.3f) /// 
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	coeflabel(zpalter "Alter" _cons "Konstante") ///
	star(+ 0.10 * 0.05 ** 0.01 *** 0.001 **** 0.0001)
```

Die Klammern können wir mit `noparentheses` unterdrücken oder mit `brackets` auf `[]` ändern.

### Neben- statt untereinander

Dafür steht uns `wide` zur Verfügung:
```{stata reg09, eval = F}
esttab reg1, b se(%9.3f) /// 
	wide ///
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	coeflabel(zpalter "Alter" _cons "Konstante") ///
	title(Modelltitel) 	///
	addnotes("erste Anmerkung" "zweite Anmerkung darunter")
```


```{stata reg09b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, b se(%9.3f) /// 
	wide ///
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	coeflabel(zpalter "Alter" _cons "Konstante") ///
	title(Modelltitel) 	///
	addnotes("erste Anmerkung" "zweite Anmerkung darunter")
```

Leider funktioniert das nicht für mehr als zwei Kennzahlen:
```{stata reg11, eval = F}
esttab reg1,b se(%9.3f) ci(%9.3f) p(%9.3f) /// 
			wide ///
			stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
			coeflabel(zpalter "Alter" _cons "Konstante") ///
			star(+ 0.10 * 0.05 ** 0.01 *** 0.001 **** 0.0001) ///
			title(Modelltitel)      ///
			addnotes("erste Anmerkung" "zweite Anmerkung darunter")
```


```{stata reg11b, error = T, echo =F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1,b se(%9.3f) ci(%9.3f) p(%9.3f) /// 
			wide ///
			stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
			coeflabel(zpalter "Alter" _cons "Konstante") ///
			star(+ 0.10 * 0.05 ** 0.01 *** 0.001 **** 0.0001) ///
			title(Modelltitel)      ///
			addnotes("erste Anmerkung" "zweite Anmerkung darunter")
```

Hier müssen wir dann auf `cells()` und `""` zurückgreifen.
Mit ` ci_l` und `ci_u` statt ` ci` bekommen wir außerdem die untere und obere KI-Grenze in separaten Spalten angezeigt, was das Ganze etwas übersichtlicher macht:
```{stata reg12, eval = F}
esttab reg1, cells("b se(fmt(%9.3f)) ci(fmt(%9.2f)) p(fmt(%9.3f))")
esttab reg1, cells("b se(fmt(%9.3f)) ci_l(fmt(%9.2f)) ci_u(fmt(%9.2f)) p(fmt(%9.3f))") // Übersichtlicher: KIs aufteilen in zwei Spalten
```


```{stata reg12b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, cells("b se(fmt(%9.3f)) ci(fmt(%9.2f)) p(fmt(%9.3f))")
esttab reg1, cells("b se(fmt(%9.3f)) ci_l(fmt(%9.2f)) ci_u(fmt(%9.2f)) p(fmt(%9.3f))") // Übersichtlicher: KIs aufteilen in zwei Spalten
```


Auch das können wir labeln - mit `collabels`:
```{stata reg13, eval = F}
esttab reg1, cells("b se(fmt(%9.3f)) ci_l(fmt(%9.2f)) ci_u(fmt(%9.2f)) p(fmt(%9.3f))") ///
			collabels("B" "SE" "u.KI" "o.KI" "p")		// labels
```


```{stata reg13b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  reg F518_SUF c.zpalter // einfaches Regressionsmodell
  est store reg1
}
esttab reg1, cells("b se(fmt(%9.3f)) ci_l(fmt(%9.2f)) ci_u(fmt(%9.2f)) p(fmt(%9.3f))") ///
			collabels("B" "SE" "u.KI" "o.KI" "p")		// labels
```


***

**[Übung 1](#reg1)**

***



## mehrere Regressionsmodelle nebeneinander 

Häufig haben wir aber mehrere Regressionsmodelle, die aufeinander aufbauen und sich alle auf die gleiche abhängige Variable beziehen.
Für eine Übersicht werden solche Modelle häufig nebeneinander gestellt in einer Tabelle gezeigt. 
Auch das geht mit `esttab`.

Wir können nämlich mit `estimates store` (`est store`) auch mehrere Modelle speichern und dann namentlich aufrufen.

Dafür könnnen wir auch "wild cards" verwenden - also  `*` als Platzhalter für "alles oder nichts" und `?` für "irgendein Zeichen".
Mit `est dir` bekommen wir eine Liste alle gespeicherten Ergebnisse ausgegeben.
`estimates clear` löst alle Ergebnisse, `est drop name` nur das Modell `name`.

Genestete Modelle lassen sich mit einer Schleife elegant erstellen.
Wir können dafür in `global`s die  Kontrollvariablen angeben und anschließend die Modelle nacheinander schätzen lassen.
```{stata reg20, eval = F}
glo mod1 " "
glo mod2 "c.zpalter"
glo mod3 "c.zpalter##c.zpalter"
glo mod4 "c.zpalter##c.zpalter i.m1202"

forval i = 1/4 {
	xi: reg F518_SUF i.S1 ${mod`i'}
	est store regm`i'
}
esttab regm*,  b se(%9.3f)
```


```{stata reg20b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"
  
  forval i = 1/4 {
  	xi: reg F518_SUF i.S1 ${mod`i'}
  	est store regm`i'
  }
}
esttab regm*,  b se(%9.3f)
```

Auch hier lohnt sich aber natürlich etwas label-Arbeit:
```{stata reg21, eval = F}
esttab regm*,  b se(%9.3f) ///
	coeflabel(_IS1_2 "Frauen" zpalter "Alter" ///
			  c.zpalter#c.zpalter "Alter²" ///
			  _Im1202_2  "dual/schul. Abs." ///    
			  _Im1202_3  "Meister/Techniker" ///
			  _Im1202_4  "Hochschule/Uni" ///
			  _cons "Konstante") ///
	refcat(_IS1_2 "Männer" ///
		   _Im1202_2 "kein Abs.")	///
		   nomtitle ///
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	varwidth(20)
```


```{stata reg2b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"
  
  forval i = 1/4 {
  	xi: reg F518_SUF i.S1 ${mod`i'}
  	est store regm`i'
  }
  }
  esttab regm*,  b se(%9.3f) ///
	coeflabel(_IS1_2 "Frauen" zpalter "Alter" ///
			  c.zpalter#c.zpalter "Alter²" ///
			  _Im1202_2  "dual/schul. Abs." ///    
			  _Im1202_3  "Meister/Techniker" ///
			  _Im1202_4  "Hochschule/Uni" ///
			  _cons "Konstante") ///
	refcat(_IS1_2 "Männer" ///
		   _Im1202_2 "kein Abs.")	///
		   nomtitle ///
	stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	varwidth(20)
```


### Nur ein Koeffizient

Manchmal möchten wir die Tabelle etwas entrümpeln und nur den interessierenden Koeffizienten behalten, das geht mit `keep()`:
```{stata reg22, eval = F}
esttab regm*,  b se(%9.3f) keep(_IS1_2)
esttab regm*,  b se(%9.3f) keep(_IS1_2 zpalter) // mehrere mit Leerzeichen
```


```{stata reg22b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"
  
  forval i = 1/4 {
  	xi: reg F518_SUF i.S1 ${mod`i'}
  	est store regm`i'
  }
  }

esttab regm*,  b se(%9.3f) keep(_IS1_2)
esttab regm*,  b se(%9.3f) keep(_IS1_2 zpalter) // mehrere mit Leerzeichen
```


Allerdings fehlt hier jetzt die Information, welche Kontrollvariablen jeweils im Modell waren.
Da kann uns `estadd local` weiter helfen. Damit können wir einen Text zu jedem `estimate` hinzufügen und den dann unten in der Tabelle ausgeben lassen.
Wir erweitern unsere Schleife also und lassen sie nochmal laufen.
Mit `scalars("note Kontrollvariablen")` werden die vorher abgelegten `note`s dann als Zeile `Kontrollvariablen` in der Tabelle angezeigt.
Mit `modelwidth()` können wir die Breite der Spalten erhöhen.
```{stata reg23, eval = F}
glo mod1 " "
glo mod2 "c.zpalter"
glo mod3 "c.zpalter##c.zpalter"
glo mod4 "c.zpalter##c.zpalter i.m1202"

forval i = 1/4 {
	xi: reg F518_SUF i.S1 ${mod`i'}
	est store regm`i'
	estadd local note "${mod`i'}"
}
esttab regm*,  b se(%9.3f) keep(_IS1_2) scalars("note Kontrollvariablen")
esttab regm*,  b se(%9.3f) keep(_IS1_2) scalars("note Kontrollvariablen") ///
	modelwidth(25) ///
	coeflabel(_IS1_2 "Frauen") ///
	refcat(_IS1_2 "Männer")
```


```{stata reg23b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"

forval i = 1/4 {
	xi: reg F518_SUF i.S1 ${mod`i'}
	est store regm`i'
	estadd local note "${mod`i'}"
}
}

esttab regm*,  b se(%9.3f) keep(_IS1_2) scalars("note Kontrollvariablen")
esttab regm*,  b se(%9.3f) keep(_IS1_2) scalars("note Kontrollvariablen") ///
	modelwidth(25) ///
	coeflabel(_IS1_2 "Frauen") ///
	refcat(_IS1_2 "Männer")
```

Mit der `regex`-Funktion `ustrregexra("","Suchtext", "Ersetztext")` können wir aus den Variablenangaben auch noch sprechendere Bezeichnungen machen.
Die Option `quietly` vor dem `reg`-Befehl unterdrückt die Standard-Regressionstabelle von Stata.
```{stata reg24, eval = F}
forval i = 1/4 {
	quietly xi: reg F518_SUF i.S1 ${mod`i'}
	est store regm`i'
	
	loc note "${mod`i'}"
	loc note = ustrregexra("`note'","^\s", "-") // ^\s = "an Anfang Leerzeichen"
	loc note = ustrregexra("`note'","c.zpalter##c.zpalter", "Alter & Alter^2") 
	loc note = ustrregexra("`note'","c.zpalter", "Alter")
	loc note = ustrregexra("`note'"," i.m1202", ", Ausbildung")
	estadd local note "`note'"
	}
  
esttab regm*,  b se(%9.3f) keep(_IS1_2) scalars("note Kontrollvariablen") ///
	modelwidth(25) ///
	varwidth(17) ///
	coeflabel(_IS1_2 "Frauen") ///
	refcat(_IS1_2 "Männer") ///
	nomtitle
```


```{stata reg24b, echo = F}

quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"

  
  forval i = 1/4 {
  	quietly xi: reg F518_SUF i.S1 ${mod`i'}
  	est store regm`i'
  	
  	loc note "${mod`i'}"
  	loc note = ustrregexra("`note'","^\s", "-") // ^\s = "an Anfang Leerzeichen"
  	loc note = ustrregexra("`note'","c.zpalter##c.zpalter", "Alter & Alter^2") 
  	loc note = ustrregexra("`note'","c.zpalter", "Alter")
  	loc note = ustrregexra("`note'"," i.m1202", ", Ausbildung")
  	estadd local note "`note'"
  	}
  }
  
esttab regm*,  b se(%9.3f) keep(_IS1_2) scalars("note Kontrollvariablen") ///
	modelwidth(25) ///
	varwidth(17) ///
	coeflabel(_IS1_2 "Frauen") ///
	refcat(_IS1_2 "Männer") ///
	nomtitle
```


### mehrere Modellgruppen

Manchmal möchten wir auch getrennte Modelle nebeneinander stellen. Auch das geht natürlich. Hier also eine Schleife über die Werte `1` und `2` von `S1`, also getrennte Modelle für Männer und Frauen durch die Bedingung `if S1 == s` am Ende des `reg`-Befehls:
```{stata reg25, eval = F}
forvalues s = 1/2 {
		
	reg F518_SUF c.zpalter##c.zpalter if S1 == `s'
	est store reg_`s'_1
	estadd local note "Alter & Alter^2"
	
	reg F518_SUF c.zpalter##c.zpalter i.m1202  if S1 == `s'
	est store reg_`s'_2
	estadd local note "Alter & Alter^2, Ausbildung"
}
esttab reg_*
```

```{stata reg25b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"

    forvalues s = 1/2 {
    		
    	reg F518_SUF c.zpalter##c.zpalter if S1 == `s'
    	est store reg_`s'_1
    	estadd local note "Alter & Alter^2"
    	
    	reg F518_SUF c.zpalter##c.zpalter i.m1202  if S1 == `s'
    	est store reg_`s'_2
    	estadd local note "Alter & Alter^2, Ausbildung"
    }
  }
esttab reg_*
```

Mit `mgroups` können wir dann mehrere Spalten überschreiben.
`pattern` gibt dabei die Gruppierung an: `1` steht für "(nächstes) Label", `0` für "unter vorheriges einordnen".

```{stata reg26, eval = F}
esttab reg_*, r2 ///
	 mgroups("Männer" "Frauen", pattern(1 0 1 0))
esttab reg_*, r2 ///
	 mgroups("" "Männer" "Frauen", pattern(1 1 0 1 ))
```


```{stata reg26b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"

    forvalues s = 1/2 {
    		
    	reg F518_SUF c.zpalter##c.zpalter if S1 == `s'
    	est store reg_`s'_1
    	estadd local note "Alter & Alter^2"
    	
    	reg F518_SUF c.zpalter##c.zpalter i.m1202  if S1 == `s'
    	est store reg_`s'_2
    	estadd local note "Alter & Alter^2, Ausbildung"
    }
  }
esttab reg_*, r2 ///
	 mgroups("Männer" "Frauen", pattern(1 0 1 0))
esttab reg_*, r2 ///
	 mgroups("" "Männer" "Frauen", pattern(1 1 0 1 ))
```


## Einmal mit allem 


All diese Formatierungen sind natürlich kombinierbar:

```{stata 27, eval = F}
esttab reg_* , ///
		b se(%9.3f)  ///
		nomtitle ///
	 	coeflabel(_IS1_2 "Frauen" zpalter "Alter" ///
			  c.zpalter#c.zpalter "Alter²" ///
			  _Im1202_2  "dual/schul. Abs." ///    
			  _Im1202_3  "Meister/Techniker" ///
			  _Im1202_4  "Hochschule/Uni" ///
			  _cons "Konstante") ///
		stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	refcat(_IS1_2 "Männer" ///
		   _Im1202_2 "kein Abs.") ///
	 mgroups("Männer" "Frauen", pattern(1 0 1 0)) ///
  varwidth(20)
```


```{stata 27b, echo = F}
quietly{
  use "./data/BIBBBAuA_2018_short.dta", clear
  set linesize 200
  
  glo mod1 " "
  glo mod2 "c.zpalter"
  glo mod3 "c.zpalter##c.zpalter"
  glo mod4 "c.zpalter##c.zpalter i.m1202"

    forvalues s = 1/2 {
    		
    	xi: reg F518_SUF c.zpalter##c.zpalter if S1 == `s'
    	est store reg_`s'_1
    	estadd local note "Alter & Alter^2"
    	
    	xi:  reg F518_SUF c.zpalter##c.zpalter i.m1202  if S1 == `s'
    	est store reg_`s'_2
    	estadd local note "Alter & Alter^2, Ausbildung"
    }
  }
  esttab reg_* , ///
		b se(%9.3f)  ///
		nomtitle ///
	 	coeflabel(_IS1_2 "Frauen" zpalter "Alter" ///
			  c.zpalter#c.zpalter "Alter²" ///
			  _Im1202_2  "dual/schul. Abs." ///    
			  _Im1202_3  "Meister/Techniker" ///
			  _Im1202_4  "Hochschule/Uni" ///
			  _cons "Konstante") ///
		stats(r2 N, fmt(%9.3f %9.0g) labels(R² Observations)) ///
	refcat(_IS1_2 "Männer" ///
		   _Im1202_2 "kein Abs.") ///
	 mgroups("Männer" "Frauen", pattern(1 0 1 0)) ///
  varwidth(20)
```




## Übungen

### Übung {#reg1}
### Übung {#reg2}

### Übung {#reg3}

+ Erstellen Sie ein Regressionsmodell, welches 

```{stata, eval = F}
gen mig01 = Mig != 0
```
In `mig01` steht dann `0` für keinen Migrationshintergrund und `1` für Migrationshintergrund.


### Übung {#reg4}

+ Schätzen Sie getrennte Modelle für `mig01=0` und `mig01=1` mit den Kontrollvariablen aus Übung 3




+ Erstellen Sie eine Korrelationstabelle für  `zpalter` `F518_SUF` `F200` und `F1410_01`

